\documentclass{article}


\usepackage{listings}
\usepackage{titling}
\newcommand{\subtitle}[1]{%
  \posttitle{%
    \par\end{center}
    \begin{center}\large#1\end{center}
    \vskip0.5em}%
}
\title{libADT}
\subtitle{An abstract data type library written in C.}
\author{}
\date{}



\begin{document}
\lstset{language=C}

\pagenumbering{gobble}
\maketitle
\newpage{}
\pagenumbering{arabic}
\section{Lists}
Lists are an abstract data type which are used to store a collection of (often) related objects.\\
They can be ordered or unordered and are an example of a more general ADT called a 'container.
Functions for the list ADT include:
\begin{itemize}
\item {Constructor} - to instantiate a new list.
\item {Destructor} - to remove an instance of a list from memory.
\item {Add} - to add an item to the end of the list.
\item {Read} - to read the value at a given index of the list into a variable. 
\item {Remove} - to remove an item in a list at a given index.
\item {Size} - to return the number of items in the list.
\item {isEmpty} - to return true if the list is empty, otherwise false.
\item {Search} - to see if a given value exists within the list.
\end{itemize}

\subsection*{ArrayList}
\subsubsection*{Constructor}
To instantiate a new ArrayList fist initialise a pointer to a List struct.\\
Then instantiate it with the constructor method \emph{listConst()}. \\
This will initialise an integer ArrayList with a capacity of 50.
\begin{lstlisting}
    struct List* newList;
    newList = listConst();
\end{lstlisting}

\subsubsection*{Destructor}
To free a list from memory call the \emph{listDest()} method and pass the list as an argument.
\begin{lstlisting}
    struct List* newList;
    newList = listConst();

    listDest(newList);
\end{lstlisting}

\subsubsection*{listAdd(struct List* list, int entity)}
To add an item to the ArrayList use the \emph{listAdd()} method and pass the list and item as arguments.
\begin{lstlisting}
    struct List* newList;
    newList = listConst();

    listAdd(newList, 3);
    //ArrayList now reads [3] + 0's for empty initialised indexes.
\end{lstlisting}

\subsubsection*{listRead(struct List* list, int index, int* var)}
To add an item to the ArrayList use the \emph{listRead()} method and pass the list and item as arguments.
\begin{lstlisting}
    int var;
    int newList;
    listConst(newList);

    listRead(newList, 3, &var);

    printf("%d", var); //prints 3
\end{lstlisting}

\subsubsection*{listAdd(struct List* list, int entity)}
To remove an item from the ArrayList use the \emph{listRem()} method and pass the list and index to remove item.
\begin{lstlisting}
    struct List* newList;
    newList = listConst();

    listAdd(newList, 3); newList = [3]
    listRem(newList, 1); //Removes 3 from list.
\end{lstlisting}
Objects will cascade down ArrayLists when removed too.
\begin{lstlisting}
    struct List* newList;
    newList = listConst();

    listAdd(newList, 5);
    listAdd(newList, 1);
    listAdd(newList, 3);

    //List reads [5,1,3] + '0's for empty initialised indexes.

    listRem(newList, 1); //Removes '1' from index 1 of list.

    //List now reads [5,3] + '0's for empty initialised index.
\end{lstlisting}

\subsubsection*{listSize(struct List* list)}
To get the number of items currently stored in the ArrayList use the\\
\emph{listSize()} method.
\begin{lstlisting}
    struct List* newList;
    newList = listConst();

    for(int i=0; i<5; i++)
    {
        listAdd(newList, i);
    }

    printf("%d", listSize(newList)); //prints 5
\end{lstlisting}

\subsubsection*{listIsEmpty(struct List* list)}
The \emph{listIsEmpty()} method returns 1 if the ArrayList is empty otherwise 0.

\begin{lstlisting}
    struct List* newList;
    newList = listConst();

    print("%d", listIsEmpty(newList)); //prints 1

    listAdd(newList, 5); //newList = [5]

    print("%d", listIsEmpty(newList)); //prints 0
    
\end{lstlisting}

\end{document}